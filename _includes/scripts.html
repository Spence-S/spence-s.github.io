
<script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
<script>
let config = {
  particles: {
    number: { value: 15, density: { enable: false, value_area: 800 } },
    color: { value: "#1b1e34" },
    shape: {
      type: "polygon",
      stroke: { width: 0, color: "#000" },
      polygon: { nb_sides: 3 },
      image: { src: "img/github.svg", width: 100, height: 100 }
    },
    opacity: {
      value: 0.1,
      random: true,
      anim: { enable: false, speed: 0, opacity_min: 0.1, sync: false }
    },
    size: {
      value: 160,
      random: true,
      anim: { enable: false, speed: 0, size_min: 40, sync: false }
    },
    line_linked: {
      enable: true,
      distance: 500,
      color: "#000000",
      opacity: .1,
      width: 2
    },
    move: {
      enable: true,
      speed: 5,
      direction: "none",
      random: false,
      straight: false,
      out_mode: "out",
      bounce: false,
      attract: { enable: false, rotateX: 600, rotateY: 1200 }
    }
  },
  interactivity: {
    detect_on: "canvas",
    events: {
      onhover: { enable: false, mode: "grab" },
      onclick: { enable: false, mode: "push" },
      resize: true
    },
    modes: {
      grab: { distance: 400, line_linked: { opacity: .1 } },
      bubble: { distance: 400, size: 40, duration: 2, opacity: 8, speed: 3 },
      repulse: { distance: 200, duration: 0.4 },
      push: { particles_nb: 1 },
      remove: { particles_nb: 2 }
    }
  },
  retina_detect: true
};

particlesJS("particles-js", config
// {
//   particles: {
//     number: { value: 15, density: { enable: true, value_area: 800 } },
//     color: { value: "#1b1e34" },
//     shape: {
//       type: "polygon",
//       stroke: { width: 0, color: "#000" },
//       polygon: { nb_sides: 3 },
//       image: { src: "img/github.svg", width: 100, height: 100 }
//     },
//     opacity: {
//       value: 0.1,
//       random: true,
//       anim: { enable: false, speed: .9, opacity_min: 0.1, sync: false }
//     },
//     size: {
//       value: 160,
//       random: true,
//       anim: { enable: false, speed: 10, size_min: 40, sync: false }
//     },
//     line_linked: {
//       enable: true,
//       distance: 500,
//       color: "#000000",
//       opacity: .1,
//       width: 2
//     },
//     move: {
//       enable: true,
//       speed: 5,
//       direction: "none",
//       random: false,
//       straight: false,
//       out_mode: "out",
//       bounce: false,
//       attract: { enable: false, rotateX: 600, rotateY: 1200 }
//     }
//   },
//   interactivity: {
//     detect_on: "canvas",
//     events: {
//       onhover: { enable: false, mode: "grab" },
//       onclick: { enable: false, mode: "push" },
//       resize: true
//     },
//     modes: {
//       grab: { distance: 400, line_linked: { opacity: .1 } },
//       bubble: { distance: 400, size: 40, duration: 2, opacity: 8, speed: 3 },
//       repulse: { distance: 200, duration: 0.4 },
//       push: { particles_nb: 1 },
//       remove: { particles_nb: 2 }
//     }
//   },
//   retina_detect: true
// }
);

document.getElementById('stopMotion').addEventListener('click', function(){
  config.particles.move.enable = !config.particles.move.enable;
  if (config.particles.move.enable) {
    particlesJS("particles-js", config);
    this.innerHTML = "stop motion";
  } else{
    particlesJS("particles-js", config);
    this.innerHTML = "start motion"
  };
})
</script>
<script>
  // css animations probably to be removed. This is for the icons on front page
  $.fn.extend({
    animateCss: function (animationName) {
      var animationEnd = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
      this.addClass('animated ' + animationName).one(animationEnd, function() {
        $(this).removeClass('animated ' + animationName);
      });
    }
  });
</script>
<script type="text/javascript">
  $(function(){
    $('.modal').on('show.bs.modal', function(e){
      $(this).animateCss('zoomIn');
    })
    $('.modal').on('hide.bs.modal', function(e){
      $('.modal').addClass('animated zoomOut');
    });
    $('.modal').on('hidden.bs.modal', function(e){
      $('.modal').removeClass('animated zoomOut');
    });
  })
</script>
<script src="https://unpkg.com/scrollreveal/dist/scrollreveal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js" integrity="sha256-H0TPKZAP4+uKmBpntUUMrKgH4VXBQNDZumun6fvan4w=" crossorigin="anonymous"></script>
<script type="text/javascript">
$(function(){
  // Don't forget to init the view!


  var FadeTransition = Barba.BaseTransition.extend({
    start: function() {
      /**
      * This function is automatically called as soon the Transition starts
      * this.newContainerLoading is a Promise for the loading of the new container
      * (Barba.js also comes with an handy Promise polyfill!)
      */

      // As soon the loading is finished and the old page is faded out, let's fade the new page
      Promise
      .all([this.newContainerLoading, this.fadeOut()])
      .then(this.fadeIn.bind(this));
    },

    fadeOut: function() {
      /**
      * this.oldContainer is the HTMLElement of the old Container
      */

      return $(this.oldContainer).animate({ opacity: 0 }).promise();
    },

    fadeIn: function() {
      /**
      * this.newContainer is the HTMLElement of the new Container
      * At this stage newContainer is on the DOM (inside our #barba-container and with visibility: hidden)
      * Please note, newContainer is available just after newContainerLoading is resolved!
      */

      var _this = this;
      var $el = $(this.newContainer);

      $(this.oldContainer).hide();

      $el.css({
        visibility : 'visible',
        opacity : 0
      });

      $el.animate({ opacity: 1 }, 300, function() {
        /**
        * Do not forget to call .done() as soon your transition is finished!
        * .done() will automatically remove from the DOM the old Container
        */

        _this.done();
      });
    }
  });

  /**
  * Next step, you have to tell Barba to use the new Transition
  */

  Barba.Pjax.getTransition = function() {
    /**
    * Here you can use your own logic!
    * For example you can use different Transition based on the current page or link...
    */

    return FadeTransition;
  };
  var Homepage = Barba.BaseView.extend({
    namespace: 'homepage',
    onEnter: function() {
      // The new Container is ready and attached to the DOM.

      // scroll reveal for about page
      window.sr = ScrollReveal();
      sr.reveal('.timeline-item');

      // scroll to for all pages
      $('a[href*="#"]')
      // Remove links that don't actually link to anything
      .not('[href="#"]')
      .not('[href="#0"]')
      .click(function(event) {
        // On-page links
        if (
          location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '')
          &&
          location.hostname == this.hostname
        ) {
          // Figure out element to scroll to
          var target = $(this.hash);
          target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
          // Does a scroll target exist?
          if (target.length) {
            // Only prevent default if animation is actually gonna happen
            event.preventDefault();
            $('html, body').animate({
              scrollTop: target.offset().top
            }, 1000, function() {
              // Callback after animation
              // Must change focus!
              var $target = $(target);
              $target.focus();
              if ($target.is(":focus")) { // Checking if the target was focused
                return false;
              } else {
                $target.attr('tabindex','-1'); // Adding tabindex for elements not focusable
                $target.focus(); // Set focus again
              };
            });
          }
        }
      });
    },
    onEnterCompleted: function() {
      // The Transition has just finished.
    },
    onLeave: function() {
      // A new Transition toward a new page has just started.
    },
    onLeaveCompleted: function() {
      // The Container has just been removed from the DOM.
    }
  });

  Homepage.init();
  Barba.Pjax.start();
});
</script>
